//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once
#include <wmistr.h>
#include "./evntrace.h"
#include "./evntprov.h"
//
//  Initial Defs
//
#if !defined(ETW_INLINE)
#define ETW_INLINE DECLSPEC_NOINLINE __inline
#endif

#if defined(__cplusplus)
extern "C" {
#endif

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION
#if  !defined(McGenDebug)
#define McGenDebug(a,b)
#endif 


#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE     RegistrationHandle;
    TRACEHANDLE     Logger;
    ULONGLONG       MatchAnyKeyword;
    ULONGLONG       MatchAllKeyword;
    ULONG           Flags;
    ULONG           IsEnabled;
    UCHAR           Level; 
    UCHAR           Reserve;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif

//**********************************************************************
//
// Vista Down level Support 
//
//**********************************************************************

#define __WARNING_BANNED_LEGACY_INSTRUMENTATION_API_USAGE 28735

typedef
ULONG
(__stdcall *PFN_EVENT_WRITE)(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor,
    __in ULONG UserDataCount,
    __in_ecount_opt(UserDataCount) PEVENT_DATA_DESCRIPTOR UserData
    );


typedef
ULONG
(__stdcall *PFN_EVENT_REGISTER)(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __out PREGHANDLE RegHandle
    );

typedef
ULONG
(__stdcall *PFN_EVENT_UNREGISTER)(
    __in REGHANDLE RegHandle
    );

typedef
BOOLEAN
(__stdcall *PFN_EVENT_ENABLED)(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    );

ULONG __stdcall
McGenEventTracingRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __out PREGHANDLE RegHandle
    );

ULONG __stdcall
McGenEventTracingUnregister(__in PREGHANDLE RegHandle);

BOOLEAN __stdcall
McGenEventTracingEnabled(
    __in PMCGEN_TRACE_CONTEXT EnableInfo,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    );

__declspec(selectany) BOOLEAN McGenTracingSupportInit = FALSE;
__declspec(selectany) BOOLEAN McGenPreVista = FALSE;


#pragma prefast(suppress:__WARNING_ENCODE_GLOBAL_FUNCTION_POINTER, "this pointer can not be encoded");
__declspec(selectany) PFN_EVENT_WRITE  PfnEventWrite = NULL;

#pragma prefast(suppress:__WARNING_ENCODE_GLOBAL_FUNCTION_POINTER, "this pointer can not be encoded");
__declspec(selectany) PFN_EVENT_REGISTER  PfnEventRegister = McGenEventTracingRegister;

#pragma prefast(suppress:__WARNING_ENCODE_GLOBAL_FUNCTION_POINTER, "this pointer can not be encoded");
__declspec(selectany) PFN_EVENT_UNREGISTER PfnEventUnregister = NULL;



#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenControlCallback(
    __in WMIDPREQUESTCODE RequestCode,
    __in PVOID Context,
    __inout ULONG *InOutBufferSize,
    __inout PVOID Buffer
    )
/*++

Routine Description:

    This is the notification callback for Pre Vista support.

Arguments:

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)Context;
    TRACEHANDLE Logger;
    ULONG Flags;
    ULONG IsEnabled = 0;
    UCHAR Level;

    *InOutBufferSize = 0;

    switch (RequestCode) {


        case WMI_ENABLE_EVENTS:
            {
                Logger = GetTraceLoggerHandle( Buffer );
                Level = GetTraceEnableLevel(Logger);
                Flags = GetTraceEnableFlags(Logger);
                IsEnabled = 1;

                McGenDebug(1, ("[Callback] WMI_ENABLE_EVENTS Ctx %p Flags %x"
                         " Lev %d Logger %I64x\n",
                         Ctx, Flags, Level, Logger) );

                //
                // 0 for flags is considered "ALL"
                //
                if (Flags == 0) {
                    Flags = 0xFFFFFFFF;
                }

                break;
            }
        case WMI_DISABLE_EVENTS:
            {
                Logger = 0;
                Flags  = 0;
                Level  = 0;
                McGenDebug(1, ("[Callback] WMI_DISABLE_EVENTS Ctx 0x%08p\n", Ctx));
                break;
            }
        default:
            {
                return(ERROR_INVALID_PARAMETER);
            }
        }
    
    Ctx->Logger   = Logger;
    Ctx->Level    = Level;
    Ctx->Flags    = Flags;
    Ctx->IsEnabled = IsEnabled;
        

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK
    //
    // Call user defined callback down-level
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK(
        RequestCode,
        Context,
        InOutBufferSize,
        Buffer
        );
#endif
   
    return(ERROR_SUCCESS);
}

DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    __in LPCGUID SourceId,
    __in ULONG ControlCode,
    __in UCHAR Level,
    __in ULONGLONG MatchAnyKeyword,
    __in ULONGLONG MatchAllKeyword,
    __in_opt PEVENT_FILTER_DESCRIPTOR FilterData,
    __inout_opt PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Vista.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider. 

    ControlCode - The parameter indicates whether the provider 
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to 
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category 
                      of events that the provider writes. 

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider 
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            break;
 
        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif
   
    return;
}

#endif

#define MANIFEST_MAX_MOF_FIELDS_SUPPORTED 16

VOID McGenInitTracingSupport(
    VOID
    );
#pragma warning(push)
#pragma warning(disable:4068)
FORCEINLINE
ULONG __stdcall
McGenEventTracingRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __out PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function register the provider with ETW and handles OS version.

Arguments:
    ProviderId      - Provider Id to be register with ETW
    EnableCallback  - Callback to be used: 
                      Vista : McGenControlCallbackV2
                      down-level : McGenControlCallback
    CallbackContext - Context for this provider is PMCGEN_TRACE_CONTEXT
    RegHandle       - down-level is a pointer to PMCGEN_TRACE_CONTEXT

Remarks:

    Register with ETW Vista down-level, and set the RegHandle as a pointer to
    PMCGEN_TRACE_CONTEXT for this provider. For Vista registers the provider.

--*/
{
    ULONG Error = ERROR_SUCCESS;

    if(!RegHandle) {
        return ERROR_INVALID_PARAMETER;
    }

    if(*RegHandle) {
        //
        // already registered, ignore this one
        //
        goto Cleanup;
    }

    //
    // Initialize Tracing funtion pointers according to OS version
    //
    McGenInitTracingSupport();

    //
    // Vista
    //
    if(!McGenPreVista ){
        Error = PfnEventRegister(ProviderId, 
                                 (EnableCallback == NULL) ? McGenControlCallbackV2 : EnableCallback,
                                 CallbackContext,
                                 RegHandle);
    } else {
        //
        // down-level : XP/W2K3
        //
        PMCGEN_TRACE_CONTEXT Context = (PMCGEN_TRACE_CONTEXT)CallbackContext;
        TRACE_GUID_REGISTRATION TraceRegistration;
        
        if(CallbackContext == NULL) {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        *RegHandle = (REGHANDLE)CallbackContext;

        TraceRegistration.Guid = ProviderId;
        TraceRegistration.RegHandle = 0;
 
#pragma prefast(suppress:__WARNING_BANNED_LEGACY_INSTRUMENTATION_API_USAGE, "Generated Code Down-Level Support");
        Error = RegisterTraceGuids((EnableCallback == NULL) ? McGenControlCallback : (WMIDPREQUEST)EnableCallback,
                                    CallbackContext,
                                    ProviderId,
                                    1,
                                    &TraceRegistration,
                                    0, 
                                    0, 
                                    &Context->RegistrationHandle);
    }

Cleanup:
    return Error;
}


FORCEINLINE
ULONG __stdcall
McGenEventTracingUnregister(__in PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW.

Arguments:
            RegHandle is the pointer to the provider context down-level
Remarks:

    Unregister provider and disables provider context

--*/
{
    ULONG Error = ERROR_SUCCESS;

    if(!RegHandle) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!McGenTracingSupportInit){
        //
        // EventRegistermanifestmacro has not been called
        //
        return ERROR_SUCCESS;
    }

    if(!(*RegHandle)) {
        //
        // Provider has not registerd
        //
        return ERROR_SUCCESS;
    }


    //
    // Vista
    //
    if(!McGenPreVista ){
        Error = PfnEventUnregister(*RegHandle);
    } else {
        //
        // down-level : XP/W2K3
        //
        PMCGEN_TRACE_CONTEXT Context = (PMCGEN_TRACE_CONTEXT)(*RegHandle);

#pragma prefast(suppress:__WARNING_BANNED_LEGACY_INSTRUMENTATION_API_USAGE, "Generated Code Down-Level Support");
        Error = UnregisterTraceGuids(Context->RegistrationHandle);

        Context->Flags = 0;
        Context->Level = 0;
        Context->Logger = 0;
        Context->RegistrationHandle = 0;
    }

    *RegHandle = (REGHANDLE)0;
    
    return Error;    
}
#pragma warning(pop)

FORCEINLINE 
BOOLEAN __stdcall
McGenEventTracingEnabled(
    __in PMCGEN_TRACE_CONTEXT EnableInfo,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{

    if(!EnableInfo){
        return FALSE;
    }


    if(McGenPreVista){

      return ( ((EventDescriptor->Level <= EnableInfo->Level) || (EnableInfo->Level == 0)) &&
               (((ULONG)(EventDescriptor->Keyword & 0xFFFFFFFF) == 0) || ((ULONG)(EventDescriptor->Keyword & 0xFFFFFFFF) & EnableInfo->Flags)));
    }
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((EventDescriptor->Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((EventDescriptor->Keyword == (ULONGLONG)0) ||
            ((EventDescriptor->Keyword & EnableInfo->MatchAnyKeyword) &&
             ((EventDescriptor->Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;
}

#if !defined(MCGEN_TRACING_DLL)
#define MCGEN_TRACING_DLL L"advapi32.dll"
#endif
#if !defined(MCGEN_EVENTWRITE_API)
#define MCGEN_EVENTWRITE_API  "EventWrite"
#endif
#if !defined(MCGEN_EVENTREGISTER_API)
#define MCGEN_EVENTREGISTER_API   "EventRegister"
#endif
#if !defined(MCGEN_EVENTUNREGISTER_API)
#define MCGEN_EVENTUNREGISTER_API "EventUnregister"
#endif

FORCEINLINE
VOID McGenInitTracingSupport(
    VOID
    )
/*++

Routine Description:

    This function assigns at runtime the ETW API set to be use for tracing.

Arguments:

Remarks:

    At runtime assign the functions pointers for the trace APIs to be use.
    Vista use WriteEVent, else TraceEvent

--*/
{
    OSVERSIONINFO OSVersion;
    HINSTANCE TraceApiDll = NULL;
    BOOL OkVersion;

    if (McGenTracingSupportInit){
        return;
    }

    
    OSVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    

    OkVersion = GetVersionEx(&OSVersion);
    
    if (OkVersion) {

        McGenPreVista = (OSVersion.dwMajorVersion < 6);

        if (McGenPreVista) {

            goto done;

        }
        
    } 


    TraceApiDll = GetModuleHandleW(MCGEN_TRACING_DLL);
    
    if (TraceApiDll != NULL)
    {
        PfnEventWrite = (PFN_EVENT_WRITE)GetProcAddress(TraceApiDll, MCGEN_EVENTWRITE_API);

        if (NULL == PfnEventWrite) {

            if (OkVersion) {
                McGenDebug(1, ("[McGenInitTracing] Failed to load EventWrite, using PreVista ETW \n"));
            }
            
            McGenPreVista = TRUE;
            goto done;

        } 

        PfnEventRegister = (PFN_EVENT_REGISTER) GetProcAddress(TraceApiDll, MCGEN_EVENTREGISTER_API);
        
        if (NULL == PfnEventRegister) {
            McGenDebug(1, ("[McGenInitTracing] Failed to load EventRegister, using PreVista ETW \n"));
            PfnEventRegister =  McGenEventTracingRegister;
            McGenPreVista = TRUE;
            goto done;

        }

        PfnEventUnregister = (PFN_EVENT_UNREGISTER) GetProcAddress(TraceApiDll, MCGEN_EVENTUNREGISTER_API);
        
        if (NULL == PfnEventUnregister) {
            McGenDebug(1, ("[McGenInitTracing] Failed to load EventUnregister, using PreVista ETW \n"));
            PfnEventRegister = McGenEventTracingRegister;
            McGenPreVista = TRUE;
            goto done;
       }

    } else {
    
        McGenDebug(1, ("[McGenInitTracing] Failed to load %ws, using PreVista ETW \n", MCGEN_TRACING_DLL));
        McGenPreVista = TRUE;

    }

done:
    
    McGenDebug(1, ("[McGenInitTracing] Prevista %s \n", McGenPreVista ? "TRUE" : "FALSE" ));
    McGenTracingSupportInit = TRUE;
}
#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// EnableCheckMacro
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled &&  McGenEventTracingEnabled(&Context, &Descriptor))
#endif

//+
// Provider DW-YY Event Count 4
//+
EXTERN_C __declspec(selectany) const GUID DW_YY = {0x4c96d757, 0x000b, 0x4a95, {0xb2, 0x99, 0xba, 0xf6, 0xec, 0x63, 0x4c, 0xaa}};

//
// Channel
//
#define DW_YY_CHANNEL_Application 0x9

//
// Tasks
//
#define YYStartup 0x1
EXTERN_C __declspec(selectany) const GUID YY_StartupId = {0x40cc7ea2, 0xa0fe, 0x4901, {0xa8, 0x9d, 0x88, 0xec, 0x77, 0x80, 0x55, 0x68}};
#define YY_Login 0x2
EXTERN_C __declspec(selectany) const GUID YY_LoginId = {0x5a9c2c0a, 0xafef, 0x43ec, {0x8c, 0x6c, 0xd8, 0x80, 0xc2, 0xfc, 0xad, 0x15}};

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR yy_startup_begin = {0x65, 0x0, 0x9, 0x4, 0x1, 0x1, 0x8000000000000000};
#define yy_startup_begin_value 0x65
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR yy_startup_end = {0x66, 0x0, 0x9, 0x4, 0x2, 0x1, 0x8000000000000000};
#define yy_startup_end_value 0x66
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR yy_login_begin = {0x67, 0x0, 0x9, 0x4, 0x1, 0x2, 0x8000000000000000};
#define yy_login_begin_value 0x67
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR yy_login_end = {0x68, 0x0, 0x9, 0x4, 0x2, 0x2, 0x8000000000000000};
#define yy_login_end_value 0x68

//
// Note on Generate Code from Manifest XP/W2K3/Vista and above
//
//Arrays :  only constant size arrays supported, the length must be specified in manifest
//
//Strings: No support for arrays of strings 
//
//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
//GetLengthSid function to get the length.
//

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Globals 
//

EXTERN_C __declspec(selectany) REGHANDLE DW_YYHandle = (REGHANDLE)0;

EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT DW_YY_Context = {0};

//
// Register with ETW XP, W2K, W2K3, Vista +
//
#ifndef EventRegisterDW_YY
#define EventRegisterDW_YY() McGenEventTracingRegister(&DW_YY, NULL, &DW_YY_Context, &DW_YYHandle) 
#endif

//
// UnRegister with ETW
//
#ifndef EventUnregisterDW_YY
#define EventUnregisterDW_YY() McGenEventTracingUnregister(&DW_YYHandle) 
#endif

//
// Event Macro for yy_startup_begin
//
#define EventWriteyy_startup_begin()\
        MCGEN_ENABLE_CHECK(DW_YY_Context, yy_startup_begin) ?\
        MofTemplateEventDescriptor(DW_YYHandle, &yy_startup_begin, &YY_StartupId)\
        : ERROR_SUCCESS\

//
// Event Macro for yy_startup_end
//
#define EventWriteyy_startup_end()\
        MCGEN_ENABLE_CHECK(DW_YY_Context, yy_startup_end) ?\
        MofTemplateEventDescriptor(DW_YYHandle, &yy_startup_end, &YY_StartupId)\
        : ERROR_SUCCESS\

//
// Event Macro for yy_login_begin
//
#define EventWriteyy_login_begin()\
        MCGEN_ENABLE_CHECK(DW_YY_Context, yy_login_begin) ?\
        MofTemplateEventDescriptor(DW_YYHandle, &yy_login_begin, &YY_LoginId)\
        : ERROR_SUCCESS\

//
// Event Macro for yy_login_end
//
#define EventWriteyy_login_end()\
        MCGEN_ENABLE_CHECK(DW_YY_Context, yy_login_end) ?\
        MofTemplateEventDescriptor(DW_YYHandle, &yy_login_end, &YY_LoginId)\
        : ERROR_SUCCESS\

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION


//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions 
//
//
//Template from manifest : (null)
//
#ifndef MofTemplateEventDescriptor_def
#define MofTemplateEventDescriptor_def


ETW_INLINE
ULONG
MofTemplateEventDescriptor(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt LPCGUID EventGuid
    )
{

  if (! McGenPreVista) {
    return PfnEventWrite(RegHandle, Descriptor, 0, NULL);

  } else {

    EVENT_TRACE_HEADER Header;

    const MCGEN_TRACE_CONTEXT* Context = (const MCGEN_TRACE_CONTEXT*)(ULONG_PTR)RegHandle;
    //
    // Fill in header fields
    //

    Header.GuidPtr = (ULONGLONG)EventGuid;
    Header.Flags = WNODE_FLAG_TRACED_GUID |WNODE_FLAG_USE_GUID_PTR|WNODE_FLAG_USE_MOF_PTR;
    Header.Class.Version = (USHORT)Descriptor->Version;
    Header.Class.Level = Descriptor->Level;
    Header.Class.Type = Descriptor->Opcode;
    Header.Size = sizeof(EVENT_TRACE_HEADER);

    return TraceEvent(Context->Logger, &Header);
  }
}
#endif

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
};
#endif

#define MSG_DW_YY_event_101_message          0x00000065L
#define MSG_DW_YY_event_102_message          0x00000066L
#define MSG_DW_YY_event_103_message          0x00000067L
#define MSG_DW_YY_event_104_message          0x00000068L
#define MSG_opcode_Start                     0x30000001L
#define MSG_opcode_Stop                      0x30000002L
#define MSG_level_Informational              0x50000004L
#define MSG_channel_Application              0x90000001L
